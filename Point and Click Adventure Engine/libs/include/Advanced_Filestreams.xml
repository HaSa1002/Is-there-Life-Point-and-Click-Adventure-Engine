<?xml version="1.0"?>
<doc>
    <assembly>
        "Advanced_Filestreams"
    </assembly>
    <members>
        <member name="M:af.XML.checkForAttributes">
            <summary>Checks if Attributes are left</summary>
            <returns> True if attributes left</returns>
        </member>
        <member name="M:af.XML.getAttribute(af.XML.Structure*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>consumes an Attribute</summary>
            <param name="destination">the working Structure object</param>
        </member>
        <member name="M:af.XML.getKey(af.XML.Structure*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>consumes the key</summary>
            <param name="destination">the working Structure object</param>
            <returns>True if no attributes included</returns>
        </member>
        <member name="M:af.XML.skipIf">
            <summary>Checks if buffer is empty</summary>
            <exception cref="F:EmptyLine">line is empty</exception>
        </member>
        <member name="M:af.XML.eraseSpaces(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> erases spaces and tabs in front of a line</summary>
            <param name="source">String of the unformatted source</param>
            <param name="destination">String where the line goes into</param>
        </member>
        <member name="M:af.XML.manage_stream(af.XML.Action)">
            <summary> manages the filestream direction </summary>
            <param name="action">Action value</param>
        </member>
        <member name="T:af.XML.Action">
            <summary>Defines the filestream action</summary>
        </member>
        <member name="M:af.XML.write(af.XML.Structure,System.Boolean,System.UInt32)">
            <summary>Writes into a file</summary>
            <param name="file">The Structure Struct which represents a file</param>
            <param name="self">defines if it was called recursivly</param>
            <param name="run">defines the tabs, that are put infront</param>
        </member>
        <member name="M:af.XML.read(System.Boolean)">
            <summary>Reads a file</summary>
            <param name="self">defines if it was called recursivly</param>
            <returns>A Structure which is the file</returns>
        </member>
        <member name="M:af.XML.open(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Opens a file</summary>
            <param name="path">filepath</param>
            <exception cref="T:af.Exception">when the file don't exists</exception>
        </member>
        <member name="M:af.XML.getFileStruct">
            <summary>returns the filestruct that was latestly loaded</summary>
            <returns>The latest loaded Filestruct</returns>
        </member>
        <member name="M:af.XML.getFile">
            <summary>Returns the underlying std::fstream object</summary>
            <returns>The std::fstream object</returns>
        </member>
        <member name="M:af.XML.create(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Creates a file</summary>
            <param name="path">Filepath</param>
        </member>
        <member name="M:af.XML.close">
            <summary>Close a file</summary>
        </member>
        <member name="M:af.XML.Dispose">
            <summary>Default Deconstructor, but closes the file</summary>
        </member>
        <member name="M:af.XML.#ctor">
            <summary>Default constructor</summary>
        </member>
        <member name="M:af.XML.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Opens a file</summary>
            <param name="filepath">Refrence to the file, which should be opend</param>
            <remarks>If you need to create the file first use the default constructor instead and call XML::create</remarks>
        </member>
        <member name="M:af.XML.Structure.op_Equality(af.XML.Structure!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Checks if to Structure objects are identical</summary>
        </member>
        <member name="T:af.XML.Structure">
            <summary>Represents a XML File</summary>
        </member>
        <member name="M:af.XML.Attribute.op_Inequality(af.XML.Attribute!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Checks if to Structure objects aren't identical</summary>
        </member>
        <member name="M:af.XML.Attribute.op_Equality(af.XML.Attribute!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Checks if to Attribute objects are identical</summary>
        </member>
        <member name="T:af.XML.Attribute">
            <summary>Represents a the attributes of a tag</summary>
        </member>
        <member name="T:af.XML">
            <summary>Handles XML-Files</summary>
        </member>
        <member name="M:af.getline(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.Com">
            <summary>gets a line from a string</summary>
            <param name="source">where to read from</param>
            <param name="dest">where to write into</param>
            <param name="delim">delimeting character. Default: "\n"</param>
            <param name="skip_if_not_empty">If dest is not empty, nothing is read, when true</param>
        </member>
        <member name="M:af.append(std.basic_fstream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Appends content to the file</summary>
            <param name="to_append">what to append</param>
            <param name="file">Where to append</param>
        </member>
        <member name="M:af.read(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Reads the text into the given String</summary>
            <param name="destination">Where to read from</param>
            <param name="file">From where</param>
        </member>
        <member name="M:af.write(std.basic_fstream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Writes into the file</summary>
            <remarks>You allways overwrite the content. If you don't want that, you need to use append()</remarks>
            <param name="to_write">what to write into</param>
            <param name="file">where to write</param>
        </member>
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:af.XML.checkForEndingTag" wird verworfen. -->
    </members>
</doc>